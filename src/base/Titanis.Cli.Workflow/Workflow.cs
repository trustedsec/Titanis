using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Titanis.Cli.Workflow
{
	/// <summary>
	/// Provides context for a <see cref="Workflow"/>.
	/// </summary>
	public class WorkflowContext
	{
		internal WorkflowContext(Workflow workflow, ILog log)
		{
			this.Workflow = workflow;
			this.Log = log;
		}

		public Workflow Workflow { get; }
		public ILog Log { get; }
	}

	/// <summary>
	/// Represents a workflow.
	/// </summary>
	/// <remarks>
	/// Use <see cref="AddStep(WorkflowStep)"/> to build the workflow, then execute it using
	/// <see cref="ExecuteAsync(ILog, CancellationToken)"/> or
	/// <see cref="RollbackAsync(ILog, CancellationToken, bool)"/>
	/// </remarks>
	public class Workflow
	{
		private List<WorkflowStep> _steps = new List<WorkflowStep>();

		/// <summary>
		/// Adds a <see cref="WorkflowStep"/> to the workflow.
		/// </summary>
		/// <param name="step">Step to add</param>
		/// <exception cref="ArgumentNullException"><paramref name="step"/> is <see langword="null"/>.</exception>
		/// <seealso cref="WorkflowFactory"/>
		public void AddStep(WorkflowStep step)
		{
			if (step is null) throw new ArgumentNullException(nameof(step));
			this._steps.Add(step);
		}

		/// <summary>
		/// Executes the workflow.
		/// </summary>
		/// <param name="log"><see cref="ILog"/> to log to</param>
		/// <param name="cancellationToken">Cancellation token that may be used to cancel the operation</param>
		/// <exception cref="ArgumentNullException"></exception>
		/// <exception cref="WorkflowException">An exception was thrown while executing the workflow.</exception>
		/// <remarks>
		/// If an exception is thrown while executing one of the steps, the exception is
		/// wrapped in <see cref="WorkflowException"/> along with the context and index of
		/// the failed step.  To begin rollback, pass this exception to
		/// <see cref="RollbackAsync(WorkflowException, CancellationToken, bool)"/>.
		/// </remarks>
		public async Task ExecuteAsync(ILog log, CancellationToken cancellationToken)
		{
			if (log is null) throw new ArgumentNullException(nameof(log));

			var context = new WorkflowContext(this, log);

			List<int> failedSteps = new List<int>();

			int stepCount = this._steps.Count;
			int stepIndex;
			for (stepIndex = 0; stepIndex < stepCount; stepIndex++)
			{
				var step = this._steps[stepIndex];

				log.WriteTaskStart(step.Description);

				bool success = false;
				try
				{
					await step.ExecuteAsyncInternal(context, cancellationToken).ConfigureAwait(false);
					success = true;
					log.MarkTaskComplete();
				}
				catch (Exception ex)
				{
					log.WriteTaskError(ex);

					failedSteps.Add(stepIndex);
					if (!step.ContinueOnError)
						throw new WorkflowException("A error occurred while executing the workflow.", stepIndex, context, ex);
				}
			}
		}

		public async Task RollbackAsync(ILog log, CancellationToken cancellationToken, bool continueOnErrors)
		{
			if (log is null) throw new ArgumentNullException(nameof(log));

			var context = new WorkflowContext(this, log);

			await RollbackAsync(context, cancellationToken, this._steps.Count, continueOnErrors).ConfigureAwait(false);
		}

		public Task RollbackAsync(WorkflowException exception, CancellationToken cancellationToken, bool continueOnErrors)
		{
			if (exception is null) throw new ArgumentNullException(nameof(exception));

			var context = exception.WorkflowContext;
			if (context.Workflow != this)
				throw new ArgumentException("The exception was generated by a different workflow.", nameof(exception));

			return this.RollbackAsync(exception.WorkflowContext, cancellationToken, exception.FailedStepIndex, continueOnErrors);
		}

		private async Task RollbackAsync(WorkflowContext context, CancellationToken cancellationToken, int failedStepIndex, bool continueOnErrors)
		{
			var log = context.Log;
			List<int> failedSteps = new List<int>();

			while (failedStepIndex > 0)
			{
				failedStepIndex--;

				var step = this._steps[failedStepIndex];
				if (step.SkipOnRollback)
					continue;

				log.WriteTaskStart(step.RollbackMessage);

				bool success = false;
				try
				{
					await step.RollbackAsyncInternal(context, cancellationToken).ConfigureAwait(false);
					success = true;
					log.MarkTaskComplete();
				}
				catch (Exception ex)
				{
					log.WriteTaskError(ex);

					failedSteps.Add(failedStepIndex);

					if (!continueOnErrors)
						throw new WorkflowException("A error occurred while rolling back the workflow.", failedStepIndex, context, ex);
				}
			}
		}
	}
}

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Titanis.Asn1;
using Titanis.Asn1.Serialization;

namespace Titanis.Security.Kerberos
{
	/// <summary>
	/// Provides functionality to authenticate as a Kerberos client.
	/// </summary>
	public sealed class KerberosClientContext : AuthClientContext
	{
		public KerberosClientContext(
			KerberosCredential credential,
			KerberosClient client,
			ServicePrincipalName targetSpn,
			string targetRealm,
			IKerberosCallback? callback = null
			)
		{
			if (credential is null)
				throw new ArgumentNullException(nameof(credential));
			if (client is null)
				throw new ArgumentNullException(nameof(client));

			this.Credential = credential;
			this._client = client;
			this.TargetSpn = targetSpn;
			this.TargetRealm = targetRealm;
			this.RequiredCapabilities = SecurityCapabilities.MutualAuthentication | SecurityCapabilities.Integrity;
			this._callback = callback;
		}

		/// <inheritdoc/>
		public override string UserName => this.Credential.UserName;

		/// <inheritdoc/>
		public sealed override int Legs => 2;

		/// <summary>
		/// Gets the Kerberos credential to authenticate with.
		/// </summary>
		public KerberosCredential Credential { get; }
		private readonly KerberosClient _client;

		/// <inheritdoc/>
		public sealed override SecurityCapabilities SupportedCapabilities => SecurityCapabilities.Delegation | SecurityCapabilities.MutualAuthentication | SecurityCapabilities.ReplayDetection | SecurityCapabilities.SequenceDetection | SecurityCapabilities.Confidentiality | SecurityCapabilities.Integrity;

		private readonly IKerberosCallback? _callback;
		/// <inheritdoc/>
		public sealed override SecurityCapabilities NegotiatedCapabilities => this.IsComplete ? this.RequiredCapabilities : SecurityCapabilities.None;
		/// <summary>
		/// Gets a value indicating whether confidentiality has been negotiated.
		/// </summary>
		public bool NegotiatedConfidentiality => 0 != (this.NegotiatedCapabilities & SecurityCapabilities.Confidentiality);
		/// <summary>
		/// Gets a value indicating whether integrity has been negotiated.
		/// </summary>
		public bool NegotiatedIntegrity => 0 != (this.NegotiatedCapabilities & SecurityCapabilities.Integrity);

		/// <inheritdoc/>
		protected sealed override AuthClientContext DuplicateImpl()
			=> this.DuplicateKerberos();
		public KerberosClientContext DuplicateKerberos()
		{
			var dup = new KerberosClientContext(
				this.Credential,
				this._client,
				this.TargetSpn,
				this.TargetRealm
				)
			{
				RequiredCapabilities = this.RequiredCapabilities
			};
			this.CopyFieldsTo(dup);
			return dup;
		}

		/// <inheritdoc/>
		public sealed override byte RpcAuthType => 0x10;

		/// <summary>
		/// Gets the OID for Kerberos.
		/// </summary>
		public static readonly Oid KerberosOid = new Oid("1.2.840.113554.1.2.2");
		/// <summary>
		/// Gets the OID for [MS-KILE]
		/// </summary>
		public static readonly Oid MskileOid = new Oid("1.2.840.48018.1.2.2");
		/// <inheritdoc/>
		public sealed override Oid MechOid => MskileOid;

		private SessionKey GetSessionKeyStruct()
		{
			var sessionKey = this._sessionKey;
			if (sessionKey == null)
				throw new InvalidOperationException(Messages.Krb5_ContextNotInitialized);
			return sessionKey;
		}

		private bool _isComplete;
		/// <inheritdoc/>
		public sealed override bool IsComplete => this._isComplete;

		/// <inheritdoc/>
		public sealed override ServicePrincipalName? TargetSpn { get; set; }

		/// <summary>
		/// Gets the service being authenticated to.
		/// </summary>
		/// <remarks>
		/// This property must be initialized before calling <see cref="AuthClientContext.Initialize()"/>
		/// </remarks>
		public string? TargetRealm { get; set; }

		private byte[] _token;
		/// <inheritdoc/>
		public sealed override ReadOnlySpan<byte> Token => this._token;

		/// <inheritdoc/>
		public sealed override bool HasSessionKey => true;
		/// <inheritdoc/>
		public sealed override int SessionKeySize => this.GetSessionKeyStruct().key.keyvalue.Length;

		private TicketInfo _ticket;

		/// <summary>
		/// Session key generated by the client using the same EncProfile as the ticket
		/// </summary>
		private SessionKey? _initiatorSessionKey;
		private SessionKey? _acceptorSubkey;
		private SessionKey? _sessionKey;
		private bool _isAcceptorSubkey = true;

		private static TResult RunAsync<TResult>(Func<Task<TResult>> func)
			=> Task.Factory.StartNew(func, TaskCreationOptions.LongRunning).Unwrap().Result;

		private uint _sendSeqNbr;
		private uint _recvSeqNbr;

		private uint GetSeqNbrForSend()
		{
			var seqNbr = (uint)(this._sendSeqNbr++);
#if DEBUG
			Debug.WriteLine($"[krb5]: Sending with seq # {seqNbr}");
#endif
			return seqNbr;
		}

		/// <inheritdoc/>
		/// <exception cref="InvalidOperationException"><see cref="TargetSpn"/> is null or empty.</exception>
		protected sealed override ReadOnlySpan<byte> InitializeImpl()
		{
			var ticket = this._ticket;
			if (ticket == null)
			{
				if (this.TargetSpn == null)
					throw new InvalidOperationException(Messages.Krb5_NoTargetSpn);

				// TODO: This should be truly asynchronous.
				ticket = this._ticket = RunAsync(() => this._client.GetTicketAsync(
					this.TargetSpn,
					this.TargetRealm,
					this.Credential,
					null,
					CancellationToken.None));
			}

			var sessionKey = this._sessionKey = this._initiatorSessionKey = ticket.GenerateSessionKey();
			uint sendSeqNbr = KerberosClient.GenerateNonce();
			this._sendSeqNbr = sendSeqNbr;
			APOptions options = this.IsMutualAuthRequired
				? APOptions.MutualRequired
				: APOptions.None
				;
			var gssFlags = this.RequiredCapabilities;
			var apreq = this._client.CreateAPReq(
				ticket,
				sessionKey.key,
				sendSeqNbr,
				options,
				gssFlags
				);

			var encoder = Asn1DerEncoding.CreateDerEncoder();
			encoder.EncodeObjTlv(apreq);

			this._callback?.OnSendingApreq(this, this.TargetSpn, ticket, this.Credential, gssFlags, sessionKey, sendSeqNbr);

			if (!this.IsDceRpcStyle)
			{
				encoder.GetWriter().WriteUInt16BE((ushort)GssapiTokenId.APRep);
				encoder.EncodeOid(new Asn1Oid(KerberosOid));
				encoder.EncodeCloseTlvHeader(new Asn1Tag(0x60), 0);
				Asn1.Krb5Token tokenStruc = new Asn1.Krb5Token
				{
					mechId = new Asn1Oid(KerberosOid),
					tokenId = GssapiTokenId.APReq,
					apreq = apreq
				};

				return this._token = Asn1DerEncoder.EncodeTlv(tokenStruc).ToArray();
			}
			else
			{
				return this._token = encoder.GetBytes().ToArray();
			}
		}

		/// <inheritdoc/>
		protected sealed override ReadOnlySpan<byte> InitializeWithToken(ReadOnlySpan<byte> token)
		{
			Asn1.KerberosV5Spec2.AP_REP_Unnamed_5 aprep;
			if (!this.IsDceRpcStyle)
			{
				Asn1.Krb5Token tokenStruc = Asn1DerDecoder.Decode<Asn1.Krb5Token>(token.ToArray());
				if (tokenStruc.tokenId == GssapiTokenId.APRep)
				{
					aprep = tokenStruc.aprep.Value;
				}
				else
				{
					// TODO: More informative error
					throw new FormatException();
				}
			}
			else
			{
				aprep = Asn1DerDecoder.Decode<Asn1.KerberosV5Spec2.AP_REP>(token.ToArray()).Value;
			}

			var aprep_encPart = this._ticket.SessionKey.DecryptTlv<Asn1.KerberosV5Spec2.EncPart_APRep>(
				KeyUsage.APRep_EncPart,
				aprep.enc_part
				).Value;
			if (aprep_encPart.seq_number.HasValue)
				this._recvSeqNbr = aprep_encPart.seq_number.Value;
			// UNDONE: Technically this is allowed if the seq-number is 0.  I don't like it.
			//else if (0 != (this._gssFlags & GssapiContextFlags.Sequence))
			//	throw new SecurityException();

			if (aprep_encPart.subkey != null)
			{
				this._acceptorSubkey = this._client.CreateSessionKeyFor(aprep_encPart.subkey);
				this._sessionKey = this._acceptorSubkey;
				this._isAcceptorSubkey = true;
			}

			this._callback?.OnReceivedAprep(this, this._recvSeqNbr, this._acceptorSubkey);

			if (this.IsDceRpcStyle)
			{
				var now = KerberosTime.Now();
				aprep_encPart.subkey = null;
				aprep_encPart.ctime = now.dt;
				aprep_encPart.cusec = now.usec;
				Asn1.KerberosV5Spec2.AP_REP aprep2 = new()
				{
					Value = new Asn1.KerberosV5Spec2.AP_REP_Unnamed_5
					{
						pvno = 5,
						msg_type = (byte)KrbMessageType.Aprep,
						enc_part = this._ticket.SessionKey.EncryptTlv(
							KeyUsage.APRep_EncPart,
							new Asn1.KerberosV5Spec2.EncPart_APRep
							{
								Value = aprep_encPart
								//Value = new Asn1.KerberosV5Spec2.EncAPRepPart_Unnamed_6
								//{
								//	ctime = KerberosClient.GetKerbNow(),
								//	cusec = (uint)DateTime.UtcNow.Millisecond,
								//	seq_number = (uint)this._sendSeqNbr,
								//}
							})
					}
				};
				var respToken = Asn1DerEncoder.EncodeTlv(aprep2);
				this._token = respToken.ToArray();
			}
			else
			{
				this._token = null;
			}

			this._isComplete = true;
			return this._token;
		}

		/// <inheritdoc/>
		protected sealed override ReadOnlySpan<byte> GetSessionKeyImpl()
		{
			return this.GetSessionKeyStruct().key.keyvalue;
		}

		private static Exception MakeBadMacSizeException(string paramName)
		{
			return new ArgumentException("The buffer provided for the message authentication code does not match the size required by the security provider.", paramName);
		}


		/// <inheritdoc/>
		public sealed override int SignTokenSize => this.GetSessionKeyStruct().EncryptionProfile.SignTokenSize;
		/// <inheritdoc/>
		/// <remarks>
		/// The value of this property depends on which encryption profile was negotiated.
		/// </remarks>
		public sealed override int SealHeaderSize => this.GetSessionKeyStruct().EncryptionProfile.SealHeaderSize;
		/// <inheritdoc/>
		/// <remarks>
		/// The value of this property depends on which encryption profile was negotiated.
		/// </remarks>
		public sealed override int SealTrailerSize => this.GetSessionKeyStruct().EncryptionProfile.SealTrailerSize;

		/// <inheritdoc/>
		public sealed override void SignMessage(
			in MessageSignParams signParams,
			MessageSignOptions options
			)
		{
			if (signParams.MacBuffer.Length != this.SignTokenSize)
				throw MakeBadMacSizeException(nameof(signParams));

			var sessionKey = this.GetSessionKeyStruct();
			var flags = this._isAcceptorSubkey
				? (WrapFlags.AcceptorSubkey)
				: WrapFlags.None;

			var seqNbr = this.GetSeqNbrForSend();
			sessionKey.SignMessage(
				KeyUsage.InitiatorSign,
				seqNbr,
				flags,
				in signParams
				);
		}

		public sealed override void VerifyMessage(
			in MessageVerifyParams verifyParams,
			MessageSignOptions options)
		{
			if (verifyParams.MacBuffer.Length != this.SignTokenSize)
				throw MakeBadMacSizeException(nameof(verifyParams));

			var sessionKey = this.GetSessionKeyStruct();
			var flags = WrapFlags.SentByAcceptor | (this._isAcceptorSubkey
				? (WrapFlags.AcceptorSubkey)
				: WrapFlags.None);

			uint seqNbr = (uint)(this._recvSeqNbr++);
			sessionKey.VerifySignature(
				KeyUsage.AcceptorSign,
				seqNbr,
				flags,
				verifyParams
				);
		}

		/// <inheritdoc/>
		public sealed override void SealMessage(in MessageSealParams sealParams)
		{
			Debug.Assert(this.NegotiatedConfidentiality);
			var sessionKey = this.GetSessionKeyStruct();

			uint seqNbr = this.GetSeqNbrForSend();
			var flags = this._isAcceptorSubkey
				? (WrapFlags.Sealed | WrapFlags.AcceptorSubkey)
				: WrapFlags.Sealed;
			sessionKey.SealMessage(
				KeyUsage.InitiatorSeal,
				seqNbr,
				flags,
				in sealParams
				);
		}

		/// <inheritdoc/>
		public sealed override void UnsealMessage(in MessageSealParams unsealParams)
		{
			SessionKey sessionKey = this.GetSessionKeyStruct();

			uint seqNbr = (uint)(this._recvSeqNbr++);
			var flags = this._isAcceptorSubkey
				? (WrapFlags.Sealed | WrapFlags.AcceptorSubkey)
				: WrapFlags.Sealed;

			sessionKey.UnsealMessage(
				KeyUsage.AcceptorSeal,
				seqNbr,
				flags | WrapFlags.SentByAcceptor,
				in unsealParams);
		}
	}
}
